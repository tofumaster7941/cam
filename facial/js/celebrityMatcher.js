/**
 * Celebrity Matcher System
 * Compares live face to reference images based on geometric ratios
 */
import { FaceLandmarker, FilesetResolver } from '@mediapipe/tasks-vision';

export class CelebrityMatcher {
    constructor() {
        this.landmarker = null;
        this.references = [];
        this.isReady = false;
        this.bestMatch = null;
        this.bestMatch = null;
    }

    reset() {
        this.bestMatch = null;
        console.log("Matcher state reset");
    }

    async init() {
        // Initialize independent FaceLandmarker for static image analysis
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
        );

        this.landmarker = await FaceLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                delegate: "GPU"
            },
            runningMode: "IMAGE",
            numFaces: 1,
            // We need 478 landmarks (with iris) for better eye metrics
            refineLandmarks: true
        });

        console.log("Celebrity Matcher Initialized");
        await this.loadReferences();
    }

    async loadReferences() {
        try {
            // Try to load user-provided index (generated by python script)
            const response = await fetch('./reference_faces/faces.json');
            if (response.ok) {
                const fileList = await response.json();
                console.log('Loading custom references:', fileList);

                for (const filename of fileList) {
                    const name = filename.split('.')[0].replace(/[_-]/g, ' ');
                    await this.addReference(name, `./reference_faces/${filename}`);
                }
            } else {
                throw new Error('No custom index');
            }
        } catch (e) {
            console.log('Using default references (No custom index found)');
            // Defaults
            await this.addReference('Brad Pitt', 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Brad_Pitt_2019_by_Glenn_Francis.jpg/330px-Brad_Pitt_2019_by_Glenn_Francis.jpg');
            await this.addReference('Angelina Jolie', 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/Angelina_Jolie_2_June_2014_%28cropped%29.jpg/330px-Angelina_Jolie_2_June_2014_%28cropped%29.jpg');
        }
    }

    async addReference(name, url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                try {
                    const results = this.landmarker.detect(img);
                    if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                        const features = this.extractGeometricFeatures(results.faceLandmarks[0]);
                        this.references.push({ name, features, image: url });
                        console.log(`Added reference: ${name}`);
                        resolve(true);
                    } else {
                        console.warn(`No face detected in ${name}`);
                        resolve(false);
                    }
                } catch (e) {
                    console.warn(`Failed to process ${name}`, e);
                    resolve(false);
                }
            };
            img.onerror = () => {
                console.warn(`Failed to load image for ${name}`);
                resolve(false);
            };
            img.src = url;
        });
    }

    /**
     * Extract ratio-based features
     */
    extractGeometricFeatures(landmarks) {
        // Distance helper
        const d = (i1, i2) => {
            const p1 = landmarks[i1];
            const p2 = landmarks[i2];
            // Euclidean distance
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
        };

        // Key Landmarks (478 topology)
        // 468, 473: Left/Right Iris Centers
        // 234, 454: Left/Right Face edge (Cheekbones)
        // 10, 152: Top/Bottom Face (Forehead/Chin)
        // 61, 291: Mouth corners
        // 1, 6: Nose Tip, Nose Root

        // Measurements
        const faceHeight = d(10, 152); // Normalizer (Face Height)

        return {
            // Aspect Ratios (normalized by Face Height)
            faceWidth: d(234, 454) / faceHeight,
            interEye: d(468, 473) / faceHeight,
            noseWidth: d(98, 327) / faceHeight, // Alar base
            mouthWidth: d(61, 291) / faceHeight,
            jawWidth: d(172, 397) / faceHeight, // Gonial angles approx
            chinHeight: d(17, 152) / faceHeight, // Lower lip to chin

            // Internal Ratios (invariant to global scale)
            eyeToMouth: d(468, 61) / d(473, 291), // Symmetry check ish
            noseToMouth: d(1, 0) / faceHeight // Nose tip to upper lip
        };
    }

    findMatch(liveFaceLandmarks) {
        if (!this.references.length) return null;

        const liveFeatures = this.extractGeometricFeatures(liveFaceLandmarks);

        // Find closest vector
        let bestScore = Infinity;
        let match = null;

        // Calculate scores for all references
        const matches = this.references.map(ref => {
            let score = 0;
            const f1 = liveFeatures;
            const f2 = ref.features;

            // Weighted Euclidean Distance
            score += Math.abs(f1.faceWidth - f2.faceWidth) * 1.5;
            score += Math.abs(f1.interEye - f2.interEye) * 1.2;
            score += Math.abs(f1.jawWidth - f2.jawWidth) * 1.2;
            score += Math.abs(f1.noseWidth - f2.noseWidth);
            score += Math.abs(f1.mouthWidth - f2.mouthWidth);
            score += Math.abs(f1.chinHeight - f2.chinHeight);

            // Similarity percentage
            const similarity = Math.max(0, 100 - (score * 100)).toFixed(1);

            return {
                name: ref.name,
                score: score,
                similarity: similarity,
                image: ref.image
            };
        });

        // Sort by score (ascending: lower distance is better)
        matches.sort((a, b) => a.score - b.score);

        // Get Top 3
        const top3 = matches.slice(0, 3);
        const best = top3[0];

        return {
            bestMatch: best,
            top3: top3
        };
    }
}
